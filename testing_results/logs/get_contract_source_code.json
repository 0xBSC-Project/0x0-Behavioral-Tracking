{
  "method": "get_contract_source_code",
  "module": "contracts",
  "kwargs": {
    "address": "0x0000000000000000000000000000000000001004"
  },
  "log_timestamp": "2021-03-04-11:56:12",
  "res": [
    {
      "SourceCode": "// File: contracts/interface/IBEP20.sol\r\n\r\npragma solidity 0.6.4;\r\n\r\ninterface IBEP20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the token decimals.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n\r\n    /**\r\n     * @dev Returns the token symbol.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the token name.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the bep token owner.\r\n     */\r\n    function getOwner() external view returns (address);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address _owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/interface/ITokenHub.sol\r\n\r\npragma solidity 0.6.4;\r\n\r\ninterface ITokenHub {\r\n\r\n  function getMiniRelayFee() external view returns(uint256);\r\n\r\n  function getContractAddrByBEP2Symbol(bytes32 bep2Symbol) external view returns(address);\r\n\r\n  function getBep2SymbolByContractAddr(address contractAddr) external view returns(bytes32);\r\n\r\n  function bindToken(bytes32 bep2Symbol, address contractAddr, uint256 decimals) external;\r\n\r\n  function unbindToken(bytes32 bep2Symbol, address contractAddr) external;\r\n\r\n  function transferOut(address contractAddr, address recipient, uint256 amount, uint64 expireTime)\r\n    external payable returns (bool);\r\n\r\n  /* solium-disable-next-line */\r\n  function batchTransferOutBNB(address[] calldata recipientAddrs, uint256[] calldata amounts, address[] calldata refundAddrs,\r\n    uint64 expireTime) external payable returns (bool);\r\n\r\n}\r\n\r\n// File: contracts/interface/IParamSubscriber.sol\r\n\r\npragma solidity 0.6.4;\r\n\r\ninterface IParamSubscriber {\r\n    function updateParam(string calldata key, bytes calldata value) external;\r\n}\r\n\r\n// File: contracts/interface/IApplication.sol\r\n\r\npragma solidity 0.6.4;\r\n\r\ninterface IApplication {\r\n    /**\r\n     * @dev Handle syn package\r\n     */\r\n    function handleSynPackage(uint8 channelId, bytes calldata msgBytes) external returns(bytes memory responsePayload);\r\n\r\n    /**\r\n     * @dev Handle ack package\r\n     */\r\n    function handleAckPackage(uint8 channelId, bytes calldata msgBytes) external;\r\n\r\n    /**\r\n     * @dev Handle fail ack package\r\n     */\r\n    function handleFailAckPackage(uint8 channelId, bytes calldata msgBytes) external;\r\n}\r\n\r\n// File: contracts/interface/ICrossChain.sol\r\n\r\npragma solidity 0.6.4;\r\n\r\ninterface ICrossChain {\r\n    /**\r\n     * @dev Send package to Binance Chain\r\n     */\r\n    function sendSynPackage(uint8 channelId, bytes calldata msgBytes, uint256 relayFee) external;\r\n}\r\n\r\n// File: contracts/interface/ISystemReward.sol\r\n\r\npragma solidity 0.6.4;\r\n\r\ninterface ISystemReward {\r\n  function claimRewards(address payable to, uint256 amount) external returns(uint256 actualAmount);\r\n}\r\n\r\n// File: contracts/lib/SafeMath.sol\r\n\r\npragma solidity 0.6.4;\r\n\r\n/**\r\n * Copyright (c) 2016-2019 zOS Global Limited\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/lib/RLPEncode.sol\r\n\r\npragma solidity 0.6.4;\r\n\r\nlibrary RLPEncode {\r\n\r\n    uint8 constant STRING_OFFSET = 0x80;\r\n    uint8 constant LIST_OFFSET = 0xc0;\r\n\r\n    /**\r\n     * @notice Encode string item\r\n     * @param self The string (ie. byte array) item to encode\r\n     * @return The RLP encoded string in bytes\r\n     */\r\n    function encodeBytes(bytes memory self) internal pure returns (bytes memory) {\r\n        if (self.length == 1 && self[0] <= 0x7f) {\r\n            return self;\r\n        }\r\n        return mergeBytes(encodeLength(self.length, STRING_OFFSET), self);\r\n    }\r\n\r\n    /**\r\n     * @notice Encode address\r\n     * @param self The address to encode\r\n     * @return The RLP encoded address in bytes\r\n     */\r\n    function encodeAddress(address self) internal pure returns (bytes memory) {\r\n        bytes memory b;\r\n        assembly {\r\n            let m := mload(0x40)\r\n            mstore(add(m, 20), xor(0x140000000000000000000000000000000000000000, self))\r\n            mstore(0x40, add(m, 52))\r\n            b := m\r\n        }\r\n        return encodeBytes(b);\r\n    }\r\n\r\n    /**\r\n     * @notice Encode uint\r\n     * @param self The uint to encode\r\n     * @return The RLP encoded uint in bytes\r\n     */\r\n    function encodeUint(uint self) internal pure returns (bytes memory) {\r\n        return encodeBytes(toBinary(self));\r\n    }\r\n\r\n    /**\r\n     * @notice Encode int\r\n     * @param self The int to encode\r\n     * @return The RLP encoded int in bytes\r\n     */\r\n    function encodeInt(int self) internal pure returns (bytes memory) {\r\n        return encodeUint(uint(self));\r\n    }\r\n\r\n    /**\r\n     * @notice Encode bool\r\n     * @param self The bool to encode\r\n     * @return The RLP encoded bool in bytes\r\n     */\r\n    function encodeBool(bool self) internal pure returns (bytes memory) {\r\n        bytes memory rs = new bytes(1);\r\n        if (self) {\r\n            rs[0] = bytes1(uint8(1));\r\n        }\r\n        return rs;\r\n    }\r\n\r\n    /**\r\n     * @notice Encode list of items\r\n     * @param self The list of items to encode, each item in list must be already encoded\r\n     * @return The RLP encoded list of items in bytes\r\n     */\r\n    function encodeList(bytes[] memory self) internal pure returns (bytes memory) {\r\n        if (self.length == 0) {\r\n            return new bytes(0);\r\n        }\r\n        bytes memory payload = self[0];\r\n        for (uint i = 1; i < self.length; i++) {\r\n            payload = mergeBytes(payload, self[i]);\r\n        }\r\n        return mergeBytes(encodeLength(payload.length, LIST_OFFSET), payload);\r\n    }\r\n\r\n    /**\r\n     * @notice Concat two bytes arrays\r\n     * @param _preBytes The first bytes array\r\n     * @param _postBytes The second bytes array\r\n     * @return The merged bytes array\r\n     */\r\n    function mergeBytes(\r\n        bytes memory _preBytes,\r\n        bytes memory _postBytes\r\n    )\r\n    internal\r\n    pure\r\n    returns (bytes memory)\r\n    {\r\n        bytes memory tempBytes;\r\n\r\n        assembly {\r\n        // Get a location of some free memory and store it in tempBytes as\r\n        // Solidity does for memory variables.\r\n            tempBytes := mload(0x40)\r\n\r\n        // Store the length of the first bytes array at the beginning of\r\n        // the memory for tempBytes.\r\n            let length := mload(_preBytes)\r\n            mstore(tempBytes, length)\r\n\r\n        // Maintain a memory counter for the current write location in the\r\n        // temp bytes array by adding the 32 bytes for the array length to\r\n        // the starting location.\r\n            let mc := add(tempBytes, 0x20)\r\n        // Stop copying when the memory counter reaches the length of the\r\n        // first bytes array.\r\n            let end := add(mc, length)\r\n\r\n            for {\r\n            // Initialize a copy counter to the start of the _preBytes data,\r\n            // 32 bytes into its memory.\r\n                let cc := add(_preBytes, 0x20)\r\n            } lt(mc, end) {\r\n            // Increase both counters by 32 bytes each iteration.\r\n                mc := add(mc, 0x20)\r\n                cc := add(cc, 0x20)\r\n            } {\r\n            // Write the _preBytes data into the tempBytes memory 32 bytes\r\n            // at a time.\r\n                mstore(mc, mload(cc))\r\n            }\r\n\r\n        // Add the length of _postBytes to the current length of tempBytes\r\n        // and store it as the new length in the first 32 bytes of the\r\n        // tempBytes memory.\r\n            length := mload(_postBytes)\r\n            mstore(tempBytes, add(length, mload(tempBytes)))\r\n\r\n        // Move the memory counter back from a multiple of 0x20 to the\r\n        // actual end of the _preBytes data.\r\n            mc := end\r\n        // Stop copying when the memory counter reaches the new combined\r\n        // length of the arrays.\r\n            end := add(mc, length)\r\n\r\n            for {\r\n                let cc := add(_postBytes, 0x20)\r\n            } lt(mc, end) {\r\n                mc := add(mc, 0x20)\r\n                cc := add(cc, 0x20)\r\n            } {\r\n                mstore(mc, mload(cc))\r\n            }\r\n\r\n        // Update the free-memory pointer by padding our last write location\r\n        // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\r\n        // next 32 byte block, then round down to the nearest multiple of\r\n        // 32. If the sum of the length of the two arrays is zero then add\r\n        // one before rounding down to leave a blank 32 bytes (the length block with 0).\r\n            mstore(0x40, and(\r\n            add(add(end, iszero(add(length, mload(_preBytes)))), 31),\r\n            not(31) // Round down to the nearest 32 bytes.\r\n            ))\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n\r\n    /**\r\n     * @notice Encode the first byte, followed by the `length` in binary form if `length` is more than 55.\r\n     * @param length The length of the string or the payload\r\n     * @param offset `STRING_OFFSET` if item is string, `LIST_OFFSET` if item is list\r\n     * @return RLP encoded bytes\r\n     */\r\n    function encodeLength(uint length, uint offset) internal pure returns (bytes memory) {\r\n        require(length < 256**8, \"input too long\");\r\n        bytes memory rs = new bytes(1);\r\n        if (length <= 55) {\r\n            rs[0] = byte(uint8(length + offset));\r\n            return rs;\r\n        }\r\n        bytes memory bl = toBinary(length);\r\n        rs[0] = byte(uint8(bl.length + offset + 55));\r\n        return mergeBytes(rs, bl);\r\n    }\r\n\r\n    /**\r\n     * @notice Encode integer in big endian binary form with no leading zeroes\r\n     * @param x The integer to encode\r\n     * @return RLP encoded bytes\r\n     */\r\n    function toBinary(uint x) internal pure returns (bytes memory) {\r\n        bytes memory b = new bytes(32);\r\n        assembly {\r\n            mstore(add(b, 32), x)\r\n        }\r\n        uint i;\r\n        if (x & 0xffffffffffffffffffffffffffffffffffffffffffffffff0000000000000000 == 0) {\r\n            i = 24;\r\n        } else if (x & 0xffffffffffffffffffffffffffffffff00000000000000000000000000000000 == 0) {\r\n            i = 16;\r\n        } else {\r\n            i = 0;\r\n        }\r\n        for (; i < 32; i++) {\r\n            if (b[i] != 0) {\r\n                break;\r\n            }\r\n        }\r\n        uint length = 32 - i;\r\n        bytes memory rs = new bytes(length);\r\n        assembly {\r\n            mstore(add(rs, length), x)\r\n            mstore(rs, length)\r\n        }\r\n        return rs;\r\n    }\r\n}\r\n\r\n// File: contracts/lib/RLPDecode.sol\r\n\r\npragma solidity 0.6.4;\r\n\r\nlibrary RLPDecode {\r\n    uint8 constant STRING_SHORT_START = 0x80;\r\n    uint8 constant STRING_LONG_START  = 0xb8;\r\n    uint8 constant LIST_SHORT_START   = 0xc0;\r\n    uint8 constant LIST_LONG_START    = 0xf8;\r\n\r\n    uint8 constant WORD_SIZE = 32;\r\n\r\n    struct RLPItem {\r\n        uint len;\r\n        uint memPtr;\r\n    }\r\n\r\n    struct Iterator {\r\n        RLPItem item;   // Item that's being iterated over.\r\n        uint nextPtr;   // Position of the next item in the list.\r\n    }\r\n\r\n    function next(Iterator memory self) internal pure returns (RLPItem memory) {\r\n        require(hasNext(self));\r\n\r\n        uint ptr = self.nextPtr;\r\n        uint itemLength = _itemLength(ptr);\r\n        self.nextPtr = ptr + itemLength;\r\n\r\n        return RLPItem(itemLength, ptr);\r\n    }\r\n\r\n    function hasNext(Iterator memory self) internal pure returns (bool) {\r\n        RLPItem memory item = self.item;\r\n        return self.nextPtr < item.memPtr + item.len;\r\n    }\r\n\r\n    function toRLPItem(bytes memory self) internal pure returns (RLPItem memory) {\r\n        uint memPtr;\r\n        assembly {\r\n            memPtr := add(self, 0x20)\r\n        }\r\n\r\n        return RLPItem(self.length, memPtr);\r\n    }\r\n\r\n    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {\r\n        require(isList(self));\r\n\r\n        uint ptr = self.memPtr + _payloadOffset(self.memPtr);\r\n        return Iterator(self, ptr);\r\n    }\r\n\r\n    function rlpLen(RLPItem memory item) internal pure returns (uint) {\r\n        return item.len;\r\n    }\r\n\r\n    function payloadLen(RLPItem memory item) internal pure returns (uint) {\r\n        return item.len - _payloadOffset(item.memPtr);\r\n    }\r\n\r\n    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {\r\n        require(isList(item));\r\n\r\n        uint items = numItems(item);\r\n        RLPItem[] memory result = new RLPItem[](items);\r\n\r\n        uint memPtr = item.memPtr + _payloadOffset(item.memPtr);\r\n        uint dataLen;\r\n        for (uint i = 0; i < items; i++) {\r\n            dataLen = _itemLength(memPtr);\r\n            result[i] = RLPItem(dataLen, memPtr);\r\n            memPtr = memPtr + dataLen;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function isList(RLPItem memory item) internal pure returns (bool) {\r\n        if (item.len == 0) return false;\r\n\r\n        uint8 byte0;\r\n        uint memPtr = item.memPtr;\r\n        assembly {\r\n            byte0 := byte(0, mload(memPtr))\r\n        }\r\n\r\n        if (byte0 < LIST_SHORT_START)\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {\r\n        bytes memory result = new bytes(item.len);\r\n        if (result.length == 0) return result;\r\n\r\n        uint ptr;\r\n        assembly {\r\n            ptr := add(0x20, result)\r\n        }\r\n\r\n        copy(item.memPtr, ptr, item.len);\r\n        return result;\r\n    }\r\n\r\n    function toBoolean(RLPItem memory item) internal pure returns (bool) {\r\n        require(item.len == 1);\r\n        uint result;\r\n        uint memPtr = item.memPtr;\r\n        assembly {\r\n            result := byte(0, mload(memPtr))\r\n        }\r\n\r\n        return result == 0 ? false : true;\r\n    }\r\n\r\n    function toAddress(RLPItem memory item) internal pure returns (address) {\r\n        // 1 byte for the length prefix\r\n        require(item.len == 21);\r\n\r\n        return address(toUint(item));\r\n    }\r\n\r\n    function toUint(RLPItem memory item) internal pure returns (uint) {\r\n        require(item.len > 0 && item.len <= 33);\r\n\r\n        uint offset = _payloadOffset(item.memPtr);\r\n        require(item.len >= offset, \"length is less than offset\");\r\n        uint len = item.len - offset;\r\n\r\n        uint result;\r\n        uint memPtr = item.memPtr + offset;\r\n        assembly {\r\n            result := mload(memPtr)\r\n\r\n        // shfit to the correct location if neccesary\r\n            if lt(len, 32) {\r\n                result := div(result, exp(256, sub(32, len)))\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // enforces 32 byte length\r\n    function toUintStrict(RLPItem memory item) internal pure returns (uint) {\r\n        // one byte prefix\r\n        require(item.len == 33);\r\n\r\n        uint result;\r\n        uint memPtr = item.memPtr + 1;\r\n        assembly {\r\n            result := mload(memPtr)\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\r\n        require(item.len > 0);\r\n\r\n        uint offset = _payloadOffset(item.memPtr);\r\n        uint len = item.len - offset; // data length\r\n        bytes memory result = new bytes(len);\r\n\r\n        uint destPtr;\r\n        assembly {\r\n            destPtr := add(0x20, result)\r\n        }\r\n\r\n        copy(item.memPtr + offset, destPtr, len);\r\n        return result;\r\n    }\r\n\r\n    function numItems(RLPItem memory item) private pure returns (uint) {\r\n        if (item.len == 0) return 0;\r\n\r\n        uint count = 0;\r\n        uint currPtr = item.memPtr + _payloadOffset(item.memPtr);\r\n        uint endPtr = item.memPtr + item.len;\r\n        while (currPtr < endPtr) {\r\n            currPtr = currPtr + _itemLength(currPtr); // skip over an item\r\n            count++;\r\n        }\r\n\r\n        return count;\r\n    }\r\n\r\n    function _itemLength(uint memPtr) private pure returns (uint) {\r\n        uint itemLen;\r\n        uint byte0;\r\n        assembly {\r\n            byte0 := byte(0, mload(memPtr))\r\n        }\r\n\r\n        if (byte0 < STRING_SHORT_START)\r\n            itemLen = 1;\r\n\r\n        else if (byte0 < STRING_LONG_START)\r\n            itemLen = byte0 - STRING_SHORT_START + 1;\r\n\r\n        else if (byte0 < LIST_SHORT_START) {\r\n            uint dataLen;\r\n            assembly {\r\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\r\n                memPtr := add(memPtr, 1) // skip over the first byte\r\n\r\n                /* 32 byte word size */\r\n                dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\r\n                itemLen := add(dataLen, add(byteLen, 1))\r\n            }\r\n            require(itemLen >= dataLen, \"addition overflow\");\r\n        }\r\n\r\n        else if (byte0 < LIST_LONG_START) {\r\n            itemLen = byte0 - LIST_SHORT_START + 1;\r\n        }\r\n\r\n        else {\r\n            uint dataLen;\r\n            assembly {\r\n                let byteLen := sub(byte0, 0xf7)\r\n                memPtr := add(memPtr, 1)\r\n\r\n                dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\r\n                itemLen := add(dataLen, add(byteLen, 1))\r\n            }\r\n            require(itemLen >= dataLen, \"addition overflow\");\r\n        }\r\n\r\n        return itemLen;\r\n    }\r\n\r\n    // @return number of bytes until the data\r\n    function _payloadOffset(uint memPtr) private pure returns (uint) {\r\n        uint byte0;\r\n        assembly {\r\n            byte0 := byte(0, mload(memPtr))\r\n        }\r\n\r\n        if (byte0 < STRING_SHORT_START)\r\n            return 0;\r\n        else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START))\r\n            return 1;\r\n        else if (byte0 < LIST_SHORT_START)  // being explicit\r\n            return byte0 - (STRING_LONG_START - 1) + 1;\r\n        else\r\n            return byte0 - (LIST_LONG_START - 1) + 1;\r\n    }\r\n\r\n    /*\r\n    * @param src Pointer to source\r\n    * @param dest Pointer to destination\r\n    * @param len Amount of memory to copy from the source\r\n    */\r\n    function copy(uint src, uint dest, uint len) private pure {\r\n        if (len == 0) return;\r\n\r\n        // copy as many word sizes as possible\r\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n\r\n            src += WORD_SIZE;\r\n            dest += WORD_SIZE;\r\n        }\r\n\r\n        // left over bytes. Mask is used to remove unwanted bytes from the word\r\n        uint mask = 256 ** (WORD_SIZE - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask)) // zero out src\r\n            let destpart := and(mload(dest), mask) // retrieve the bytes\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/interface/IRelayerHub.sol\r\n\r\npragma solidity 0.6.4;\r\n\r\ninterface IRelayerHub {\r\n  function isRelayer(address sender) external view returns (bool);\r\n}\r\n\r\n// File: contracts/interface/ILightClient.sol\r\n\r\npragma solidity 0.6.4;\r\n\r\ninterface ILightClient {\r\n\r\n  function isHeaderSynced(uint64 height) external view returns (bool);\r\n\r\n  function getAppHash(uint64 height) external view returns (bytes32);\r\n\r\n  function getSubmitter(uint64 height) external view returns (address payable);\r\n\r\n}\r\n\r\n// File: contracts/System.sol\r\n\r\npragma solidity 0.6.4;\r\n\r\n\r\n\r\n\r\ncontract System {\r\n\r\n  bool public alreadyInit;\r\n\r\n  uint32 public constant CODE_OK = 0;\r\n  uint32 public constant ERROR_FAIL_DECODE = 100;\r\n\r\n  uint8 constant public BIND_CHANNELID = 0x01;\r\n  uint8 constant public TRANSFER_IN_CHANNELID = 0x02;\r\n  uint8 constant public TRANSFER_OUT_CHANNELID = 0x03;\r\n  uint8 constant public STAKING_CHANNELID = 0x08;\r\n  uint8 constant public GOV_CHANNELID = 0x09;\r\n  uint8 constant public SLASH_CHANNELID = 0x0b;\r\n  uint16 constant public bscChainID = 0x0038;\r\n\r\n  address public constant VALIDATOR_CONTRACT_ADDR = 0x0000000000000000000000000000000000001000;\r\n  address public constant SLASH_CONTRACT_ADDR = 0x0000000000000000000000000000000000001001;\r\n  address public constant SYSTEM_REWARD_ADDR = 0x0000000000000000000000000000000000001002;\r\n  address public constant LIGHT_CLIENT_ADDR = 0x0000000000000000000000000000000000001003;\r\n  address public constant TOKEN_HUB_ADDR = 0x0000000000000000000000000000000000001004;\r\n  address public constant INCENTIVIZE_ADDR=0x0000000000000000000000000000000000001005;\r\n  address public constant RELAYERHUB_CONTRACT_ADDR = 0x0000000000000000000000000000000000001006;\r\n  address public constant GOV_HUB_ADDR = 0x0000000000000000000000000000000000001007;\r\n  address public constant TOKEN_MANAGER_ADDR = 0x0000000000000000000000000000000000001008;\r\n  address public constant CROSS_CHAIN_CONTRACT_ADDR = 0x0000000000000000000000000000000000002000;\r\n\r\n\r\n  modifier onlyCoinbase() {\r\n    require(msg.sender == block.coinbase, \"the message sender must be the block producer\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyNotInit() {\r\n    require(!alreadyInit, \"the contract already init\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyInit() {\r\n    require(alreadyInit, \"the contract not init yet\");\r\n    _;\r\n  }\r\n\r\n  modifier onlySlash() {\r\n    require(msg.sender == SLASH_CONTRACT_ADDR, \"the message sender must be slash contract\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyTokenHub() {\r\n    require(msg.sender == TOKEN_HUB_ADDR, \"the message sender must be token hub contract\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyGov() {\r\n    require(msg.sender == GOV_HUB_ADDR, \"the message sender must be governance contract\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyValidatorContract() {\r\n    require(msg.sender == VALIDATOR_CONTRACT_ADDR, \"the message sender must be validatorSet contract\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyCrossChainContract() {\r\n    require(msg.sender == CROSS_CHAIN_CONTRACT_ADDR, \"the message sender must be cross chain contract\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyRelayerIncentivize() {\r\n    require(msg.sender == INCENTIVIZE_ADDR, \"the message sender must be incentivize contract\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyRelayer() {\r\n    require(IRelayerHub(RELAYERHUB_CONTRACT_ADDR).isRelayer(msg.sender), \"the msg sender is not a relayer\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyTokenManager() {\r\n    require(msg.sender == TOKEN_MANAGER_ADDR, \"the msg sender must be tokenManager\");\r\n    _;\r\n  }\r\n\r\n  // Not reliable, do not use when need strong verify\r\n  function isContract(address addr) internal view returns (bool) {\r\n    uint size;\r\n    assembly { size := extcodesize(addr) }\r\n    return size > 0;\r\n  }\r\n}\r\n\r\n// File: contracts/TokenHub.sol\r\n\r\npragma solidity 0.6.4;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract TokenHub is ITokenHub, System, IParamSubscriber, IApplication, ISystemReward {\r\n\r\n  using SafeMath for uint256;\r\n\r\n  using RLPEncode for *;\r\n  using RLPDecode for *;\r\n\r\n  using RLPDecode for RLPDecode.RLPItem;\r\n  using RLPDecode for RLPDecode.Iterator;\r\n\r\n  // BSC to BC\r\n  struct TransferOutSynPackage {\r\n    bytes32 bep2TokenSymbol;\r\n    address contractAddr;\r\n    uint256[] amounts;\r\n    address[] recipients;\r\n    address[] refundAddrs;\r\n    uint64  expireTime;\r\n  }\r\n\r\n  // BC to BSC\r\n  struct TransferOutAckPackage {\r\n    address contractAddr;\r\n    uint256[] refundAmounts;\r\n    address[] refundAddrs;\r\n    uint32 status;\r\n  }\r\n\r\n  // BC to BSC\r\n  struct TransferInSynPackage {\r\n    bytes32 bep2TokenSymbol;\r\n    address contractAddr;\r\n    uint256 amount;\r\n    address recipient;\r\n    address refundAddr;\r\n    uint64  expireTime;\r\n  }\r\n\r\n  // BSC to BC\r\n  struct TransferInRefundPackage {\r\n    bytes32 bep2TokenSymbol;\r\n    uint256 refundAmount;\r\n    address refundAddr;\r\n    uint32 status;\r\n  }\r\n\r\n  // transfer in channel\r\n  uint8 constant public   TRANSFER_IN_SUCCESS = 0;\r\n  uint8 constant public   TRANSFER_IN_FAILURE_TIMEOUT = 1;\r\n  uint8 constant public   TRANSFER_IN_FAILURE_UNBOUND_TOKEN = 2;\r\n  uint8 constant public   TRANSFER_IN_FAILURE_INSUFFICIENT_BALANCE = 3;\r\n  uint8 constant public   TRANSFER_IN_FAILURE_NON_PAYABLE_RECIPIENT = 4;\r\n  uint8 constant public   TRANSFER_IN_FAILURE_UNKNOWN = 5;\r\n\r\n  uint256 constant public MAX_BEP2_TOTAL_SUPPLY = 9000000000000000000;\r\n  uint8 constant public   MINIMUM_BEP20_SYMBOL_LEN = 2;\r\n  uint8 constant public   MAXIMUM_BEP20_SYMBOL_LEN = 8;\r\n  uint8 constant public   BEP2_TOKEN_DECIMALS = 8;\r\n  bytes32 constant public BEP2_TOKEN_SYMBOL_FOR_BNB = 0x424E420000000000000000000000000000000000000000000000000000000000; // \"BNB\"\r\n  uint256 constant public MAX_GAS_FOR_CALLING_BEP20=50000;\r\n  uint256 constant public MAX_GAS_FOR_TRANSFER_BNB=10000;\r\n\r\n  uint256 constant public INIT_MINIMUM_RELAY_FEE =2e15;\r\n  uint256 constant public REWARD_UPPER_LIMIT =1e18;\r\n  uint256 constant public TEN_DECIMALS = 1e10;\r\n\r\n  uint256 public relayFee;\r\n\r\n  mapping(address => uint256) public bep20ContractDecimals;\r\n  mapping(address => bytes32) private contractAddrToBEP2Symbol;\r\n  mapping(bytes32 => address) private bep2SymbolToContractAddr;\r\n\r\n  event transferInSuccess(address bep20Addr, address refundAddr, uint256 amount);\r\n  event transferOutSuccess(address bep20Addr, address senderAddr, uint256 amount, uint256 relayFee);\r\n  event refundSuccess(address bep20Addr, address refundAddr, uint256 amount, uint32 status);\r\n  event refundFailure(address bep20Addr, address refundAddr, uint256 amount, uint32 status);\r\n  event rewardTo(address to, uint256 amount);\r\n  event receiveDeposit(address from, uint256 amount);\r\n  event unexpectedPackage(uint8 channelId, bytes msgBytes);\r\n  event paramChange(string key, bytes value);\r\n\r\n  constructor() public {}\r\n\r\n  function init() onlyNotInit external {\r\n    relayFee = INIT_MINIMUM_RELAY_FEE;\r\n    bep20ContractDecimals[address(0x0)] = 18; // BNB decimals is 18\r\n    alreadyInit=true;\r\n  }\r\n\r\n  receive() external payable{\r\n    if (msg.value>0) {\r\n      emit receiveDeposit(msg.sender, msg.value);\r\n    }\r\n  }\r\n\r\n  function claimRewards(address payable to, uint256 amount) onlyInit onlyRelayerIncentivize external override returns(uint256) {\r\n    uint256 actualAmount = amount < address(this).balance ? amount : address(this).balance;\r\n    if (actualAmount > REWARD_UPPER_LIMIT) {\r\n      return 0;\r\n    }\r\n    if (actualAmount>0) {\r\n      to.transfer(actualAmount);\r\n      emit rewardTo(to, actualAmount);\r\n    }\r\n    return actualAmount;\r\n  }\r\n\r\n  function getMiniRelayFee() external view override returns(uint256) {\r\n    return relayFee;\r\n  }\r\n\r\n  function handleSynPackage(uint8 channelId, bytes calldata msgBytes) onlyInit onlyCrossChainContract external override returns(bytes memory) {\r\n    if (channelId == TRANSFER_IN_CHANNELID) {\r\n      return handleTransferInSynPackage(msgBytes);\r\n    } else {\r\n      // should not happen\r\n      require(false, \"unrecognized syn package\");\r\n      return new bytes(0);\r\n    }\r\n  }\r\n\r\n  function handleAckPackage(uint8 channelId, bytes calldata msgBytes) onlyInit onlyCrossChainContract external override {\r\n    if (channelId == TRANSFER_OUT_CHANNELID) {\r\n      handleTransferOutAckPackage(msgBytes);\r\n    } else {\r\n      emit unexpectedPackage(channelId, msgBytes);\r\n    }\r\n  }\r\n\r\n  function handleFailAckPackage(uint8 channelId, bytes calldata msgBytes) onlyInit onlyCrossChainContract external override {\r\n    if (channelId == TRANSFER_OUT_CHANNELID) {\r\n      handleTransferOutFailAckPackage(msgBytes);\r\n    } else {\r\n      emit unexpectedPackage(channelId, msgBytes);\r\n    }\r\n  }\r\n\r\n  function decodeTransferInSynPackage(bytes memory msgBytes) internal pure returns (TransferInSynPackage memory, bool) {\r\n    TransferInSynPackage memory transInSynPkg;\r\n\r\n    RLPDecode.Iterator memory iter = msgBytes.toRLPItem().iterator();\r\n    bool success = false;\r\n    uint256 idx=0;\r\n    while (iter.hasNext()) {\r\n      if (idx == 0) transInSynPkg.bep2TokenSymbol       = bytes32(iter.next().toUint());\r\n      else if (idx == 1) transInSynPkg.contractAddr     = iter.next().toAddress();\r\n      else if (idx == 2) transInSynPkg.amount           = iter.next().toUint();\r\n      else if (idx == 3) transInSynPkg.recipient        = ((iter.next().toAddress()));\r\n      else if (idx == 4) transInSynPkg.refundAddr       = iter.next().toAddress();\r\n      else if (idx == 5) {\r\n        transInSynPkg.expireTime       = uint64(iter.next().toUint());\r\n        success = true;\r\n      }\r\n      else break;\r\n      idx++;\r\n    }\r\n    return (transInSynPkg, success);\r\n  }\r\n\r\n  function encodeTransferInRefundPackage(TransferInRefundPackage memory transInAckPkg) internal pure returns (bytes memory) {\r\n    bytes[] memory elements = new bytes[](4);\r\n    elements[0] = uint256(transInAckPkg.bep2TokenSymbol).encodeUint();\r\n    elements[1] = transInAckPkg.refundAmount.encodeUint();\r\n    elements[2] = transInAckPkg.refundAddr.encodeAddress();\r\n    elements[3] = uint256(transInAckPkg.status).encodeUint();\r\n    return elements.encodeList();\r\n  }\r\n\r\n  function handleTransferInSynPackage(bytes memory msgBytes) internal returns(bytes memory) {\r\n    (TransferInSynPackage memory transInSynPkg, bool success) = decodeTransferInSynPackage(msgBytes);\r\n    require(success, \"unrecognized transferIn package\");\r\n    uint32 resCode = doTransferIn(transInSynPkg);\r\n    if (resCode != TRANSFER_IN_SUCCESS) {\r\n      uint256 bep2Amount = convertToBep2Amount(transInSynPkg.amount, bep20ContractDecimals[transInSynPkg.contractAddr]);\r\n      TransferInRefundPackage memory transInAckPkg = TransferInRefundPackage({\r\n          bep2TokenSymbol: transInSynPkg.bep2TokenSymbol,\r\n          refundAmount: bep2Amount,\r\n          refundAddr: transInSynPkg.refundAddr,\r\n          status: resCode\r\n      });\r\n      return encodeTransferInRefundPackage(transInAckPkg);\r\n    } else {\r\n      return new bytes(0);\r\n    }\r\n  }\r\n\r\n  function doTransferIn(TransferInSynPackage memory transInSynPkg) internal returns (uint32) {\r\n    if (transInSynPkg.contractAddr==address(0x0)) {\r\n      if (block.timestamp > transInSynPkg.expireTime) {\r\n        return TRANSFER_IN_FAILURE_TIMEOUT;\r\n      }\r\n      if (address(this).balance < transInSynPkg.amount) {\r\n        return TRANSFER_IN_FAILURE_INSUFFICIENT_BALANCE;\r\n      }\r\n      (bool success, ) = transInSynPkg.recipient.call{gas: MAX_GAS_FOR_TRANSFER_BNB, value: transInSynPkg.amount}(\"\");\r\n      if (!success) {\r\n        return TRANSFER_IN_FAILURE_NON_PAYABLE_RECIPIENT;\r\n      }\r\n      emit transferInSuccess(transInSynPkg.contractAddr, transInSynPkg.recipient, transInSynPkg.amount);\r\n      return TRANSFER_IN_SUCCESS;\r\n    } else {\r\n      if (block.timestamp > transInSynPkg.expireTime) {\r\n        return TRANSFER_IN_FAILURE_TIMEOUT;\r\n      }\r\n      if (contractAddrToBEP2Symbol[transInSynPkg.contractAddr]!= transInSynPkg.bep2TokenSymbol) {\r\n        return TRANSFER_IN_FAILURE_UNBOUND_TOKEN;\r\n      }\r\n      uint256 actualBalance = IBEP20(transInSynPkg.contractAddr).balanceOf{gas: MAX_GAS_FOR_CALLING_BEP20}(address(this));\r\n      if (actualBalance < transInSynPkg.amount) {\r\n        return TRANSFER_IN_FAILURE_INSUFFICIENT_BALANCE;\r\n      }\r\n      bool success = IBEP20(transInSynPkg.contractAddr).transfer{gas: MAX_GAS_FOR_CALLING_BEP20}(transInSynPkg.recipient, transInSynPkg.amount);\r\n      if (success) {\r\n        emit transferInSuccess(transInSynPkg.contractAddr, transInSynPkg.recipient, transInSynPkg.amount);\r\n        return TRANSFER_IN_SUCCESS;\r\n      } else {\r\n        return TRANSFER_IN_FAILURE_UNKNOWN;\r\n      }\r\n    }\r\n  }\r\n\r\n  function decodeTransferOutAckPackage(bytes memory msgBytes) internal pure returns(TransferOutAckPackage memory, bool) {\r\n    TransferOutAckPackage memory transOutAckPkg;\r\n\r\n    RLPDecode.Iterator memory iter = msgBytes.toRLPItem().iterator();\r\n    bool success = false;\r\n    uint256 idx=0;\r\n    while (iter.hasNext()) {\r\n        if (idx == 0) {\r\n          transOutAckPkg.contractAddr = iter.next().toAddress();\r\n        }\r\n        else if (idx == 1) {\r\n          RLPDecode.RLPItem[] memory list = iter.next().toList();\r\n          transOutAckPkg.refundAmounts = new uint256[](list.length);\r\n          for (uint256 index=0; index<list.length; index++) {\r\n            transOutAckPkg.refundAmounts[index] = list[index].toUint();\r\n          }\r\n        }\r\n        else if (idx == 2) {\r\n          RLPDecode.RLPItem[] memory list = iter.next().toList();\r\n          transOutAckPkg.refundAddrs = new address[](list.length);\r\n          for (uint256 index=0; index<list.length; index++) {\r\n            transOutAckPkg.refundAddrs[index] = list[index].toAddress();\r\n          }\r\n        }\r\n        else if (idx == 3) {\r\n          transOutAckPkg.status = uint32(iter.next().toUint());\r\n          success = true;\r\n        }\r\n        else {\r\n          break;\r\n        }\r\n        idx++;\r\n    }\r\n    return (transOutAckPkg, success);\r\n  }\r\n\r\n  function handleTransferOutAckPackage(bytes memory msgBytes) internal {\r\n    (TransferOutAckPackage memory transOutAckPkg, bool decodeSuccess) = decodeTransferOutAckPackage(msgBytes);\r\n    require(decodeSuccess, \"unrecognized transferOut ack package\");\r\n    doRefund(transOutAckPkg);\r\n  }\r\n\r\n  function doRefund(TransferOutAckPackage memory transOutAckPkg) internal {\r\n    if (transOutAckPkg.contractAddr==address(0x0)) {\r\n      for (uint256 index = 0; index<transOutAckPkg.refundAmounts.length; index++) {\r\n        (bool success, ) = transOutAckPkg.refundAddrs[index].call{gas: MAX_GAS_FOR_TRANSFER_BNB, value: transOutAckPkg.refundAmounts[index]}(\"\");\r\n        if (!success) {\r\n          emit refundFailure(transOutAckPkg.contractAddr, transOutAckPkg.refundAddrs[index], transOutAckPkg.refundAmounts[index], transOutAckPkg.status);\r\n        } else {\r\n          emit refundSuccess(transOutAckPkg.contractAddr, transOutAckPkg.refundAddrs[index], transOutAckPkg.refundAmounts[index], transOutAckPkg.status);\r\n        }\r\n      }\r\n    } else {\r\n      for (uint256 index = 0; index<transOutAckPkg.refundAmounts.length; index++) {\r\n        bool success = IBEP20(transOutAckPkg.contractAddr).transfer{gas: MAX_GAS_FOR_CALLING_BEP20}(transOutAckPkg.refundAddrs[index], transOutAckPkg.refundAmounts[index]);\r\n        if (success) {\r\n          emit refundSuccess(transOutAckPkg.contractAddr, transOutAckPkg.refundAddrs[index], transOutAckPkg.refundAmounts[index], transOutAckPkg.status);\r\n        } else {\r\n          emit refundFailure(transOutAckPkg.contractAddr, transOutAckPkg.refundAddrs[index], transOutAckPkg.refundAmounts[index], transOutAckPkg.status);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  function decodeTransferOutSynPackage(bytes memory msgBytes) internal pure returns (TransferOutSynPackage memory, bool) {\r\n    TransferOutSynPackage memory transOutSynPkg;\r\n\r\n    RLPDecode.Iterator memory iter = msgBytes.toRLPItem().iterator();\r\n    bool success = false;\r\n    uint256 idx=0;\r\n    while (iter.hasNext()) {\r\n      if (idx == 0) {\r\n        transOutSynPkg.bep2TokenSymbol = bytes32(iter.next().toUint());\r\n      } else if (idx == 1) {\r\n        transOutSynPkg.contractAddr = iter.next().toAddress();\r\n      } else if (idx == 2) {\r\n        RLPDecode.RLPItem[] memory list = iter.next().toList();\r\n        transOutSynPkg.amounts = new uint256[](list.length);\r\n        for (uint256 index=0; index<list.length; index++) {\r\n          transOutSynPkg.amounts[index] = list[index].toUint();\r\n        }\r\n      } else if (idx == 3) {\r\n        RLPDecode.RLPItem[] memory list = iter.next().toList();\r\n        transOutSynPkg.recipients = new address[](list.length);\r\n        for (uint256 index=0; index<list.length; index++) {\r\n          transOutSynPkg.recipients[index] = list[index].toAddress();\r\n        }\r\n      } else if (idx == 4) {\r\n        RLPDecode.RLPItem[] memory list = iter.next().toList();\r\n        transOutSynPkg.refundAddrs = new address[](list.length);\r\n        for (uint256 index=0; index<list.length; index++) {\r\n          transOutSynPkg.refundAddrs[index] = list[index].toAddress();\r\n        }\r\n      } else if (idx == 5) {\r\n        transOutSynPkg.expireTime = uint64(iter.next().toUint());\r\n        success = true;\r\n      } else {\r\n        break;\r\n      }\r\n      idx++;\r\n    }\r\n    return (transOutSynPkg, success);\r\n  }\r\n\r\n  function handleTransferOutFailAckPackage(bytes memory msgBytes) internal {\r\n    (TransferOutSynPackage memory transOutSynPkg, bool decodeSuccess) = decodeTransferOutSynPackage(msgBytes);\r\n    require(decodeSuccess, \"unrecognized transferOut syn package\");\r\n    TransferOutAckPackage memory transOutAckPkg;\r\n    transOutAckPkg.contractAddr = transOutSynPkg.contractAddr;\r\n    transOutAckPkg.refundAmounts = transOutSynPkg.amounts;\r\n    uint256 bep20TokenDecimals = bep20ContractDecimals[transOutSynPkg.contractAddr];\r\n    for (uint idx=0;idx<transOutSynPkg.amounts.length;idx++) {\r\n      transOutSynPkg.amounts[idx] = convertFromBep2Amount(transOutSynPkg.amounts[idx], bep20TokenDecimals);\r\n    }\r\n    transOutAckPkg.refundAddrs = transOutSynPkg.refundAddrs;\r\n    transOutAckPkg.status = TRANSFER_IN_FAILURE_UNKNOWN;\r\n    doRefund(transOutAckPkg);\r\n  }\r\n\r\n  function encodeTransferOutSynPackage(TransferOutSynPackage memory transOutSynPkg) internal pure returns (bytes memory) {\r\n    bytes[] memory elements = new bytes[](6);\r\n\r\n    elements[0] = uint256(transOutSynPkg.bep2TokenSymbol).encodeUint();\r\n    elements[1] = transOutSynPkg.contractAddr.encodeAddress();\r\n\r\n    uint256 batchLength = transOutSynPkg.amounts.length;\r\n\r\n    bytes[] memory amountsElements = new bytes[](batchLength);\r\n    for (uint256 index = 0; index< batchLength; index++) {\r\n      amountsElements[index] = transOutSynPkg.amounts[index].encodeUint();\r\n    }\r\n    elements[2] = amountsElements.encodeList();\r\n\r\n    bytes[] memory recipientsElements = new bytes[](batchLength);\r\n    for (uint256 index = 0; index< batchLength; index++) {\r\n       recipientsElements[index] = transOutSynPkg.recipients[index].encodeAddress();\r\n    }\r\n    elements[3] = recipientsElements.encodeList();\r\n\r\n    bytes[] memory refundAddrsElements = new bytes[](batchLength);\r\n    for (uint256 index = 0; index< batchLength; index++) {\r\n       refundAddrsElements[index] = transOutSynPkg.refundAddrs[index].encodeAddress();\r\n    }\r\n    elements[4] = refundAddrsElements.encodeList();\r\n\r\n    elements[5] = uint256(transOutSynPkg.expireTime).encodeUint();\r\n    return elements.encodeList();\r\n  }\r\n\r\n  function transferOut(address contractAddr, address recipient, uint256 amount, uint64 expireTime) external override onlyInit payable returns (bool) {\r\n    require(expireTime>=block.timestamp + 120, \"expireTime must be two minutes later\");\r\n    require(msg.value%TEN_DECIMALS==0, \"invalid received BNB amount: precision loss in amount conversion\");\r\n    bytes32 bep2TokenSymbol;\r\n    uint256 convertedAmount;\r\n    uint256 rewardForRelayer;\r\n    if (contractAddr==address(0x0)) {\r\n      require(msg.value>=amount.add(relayFee), \"received BNB amount should be no less than the sum of transferOut BNB amount and minimum relayFee\");\r\n      require(amount%TEN_DECIMALS==0, \"invalid transfer amount: precision loss in amount conversion\");\r\n      rewardForRelayer=msg.value.sub(amount);\r\n      convertedAmount = amount.div(TEN_DECIMALS); // native bnb decimals is 8 on BBC, while the native bnb decimals on BSC is 18\r\n      bep2TokenSymbol=BEP2_TOKEN_SYMBOL_FOR_BNB;\r\n    } else {\r\n      bep2TokenSymbol = contractAddrToBEP2Symbol[contractAddr];\r\n      require(bep2TokenSymbol!=bytes32(0x00), \"the contract has not been bound to any bep2 token\");\r\n      require(msg.value>=relayFee, \"received BNB amount should be no less than the minimum relayFee\");\r\n      rewardForRelayer=msg.value;\r\n      uint256 bep20TokenDecimals=bep20ContractDecimals[contractAddr];\r\n      require(bep20TokenDecimals<=BEP2_TOKEN_DECIMALS || (bep20TokenDecimals>BEP2_TOKEN_DECIMALS && amount.mod(10**(bep20TokenDecimals-BEP2_TOKEN_DECIMALS))==0), \"invalid transfer amount: precision loss in amount conversion\");\r\n      convertedAmount = convertToBep2Amount(amount, bep20TokenDecimals);// convert to bep2 amount\r\n      if (isMiniBEP2Token(bep2TokenSymbol)) {\r\n        require(convertedAmount >= 1e8 , \"For miniToken, the transfer amount must not be less than 1\");\r\n      }\r\n      require(bep20TokenDecimals>=BEP2_TOKEN_DECIMALS || (bep20TokenDecimals<BEP2_TOKEN_DECIMALS && convertedAmount>amount), \"amount is too large, uint256 overflow\");\r\n      require(convertedAmount<=MAX_BEP2_TOTAL_SUPPLY, \"amount is too large, exceed maximum bep2 token amount\");\r\n      require(IBEP20(contractAddr).transferFrom(msg.sender, address(this), amount));\r\n    }\r\n    TransferOutSynPackage memory transOutSynPkg = TransferOutSynPackage({\r\n      bep2TokenSymbol: bep2TokenSymbol,\r\n      contractAddr: contractAddr,\r\n      amounts: new uint256[](1),\r\n      recipients: new address[](1),\r\n      refundAddrs: new address[](1),\r\n      expireTime: expireTime\r\n    });\r\n    transOutSynPkg.amounts[0]=convertedAmount;\r\n    transOutSynPkg.recipients[0]=recipient;\r\n    transOutSynPkg.refundAddrs[0]=msg.sender;\r\n    ICrossChain(CROSS_CHAIN_CONTRACT_ADDR).sendSynPackage(TRANSFER_OUT_CHANNELID, encodeTransferOutSynPackage(transOutSynPkg), rewardForRelayer.div(TEN_DECIMALS));\r\n    emit transferOutSuccess(contractAddr, msg.sender, amount, rewardForRelayer);\r\n    return true;\r\n  }\r\n\r\n  function batchTransferOutBNB(address[] calldata recipientAddrs, uint256[] calldata amounts, address[] calldata refundAddrs, uint64 expireTime) external override onlyInit payable returns (bool) {\r\n    require(recipientAddrs.length == amounts.length, \"Length of recipientAddrs doesn't equal to length of amounts\");\r\n    require(recipientAddrs.length == refundAddrs.length, \"Length of recipientAddrs doesn't equal to length of refundAddrs\");\r\n    require(expireTime>=block.timestamp + 120, \"expireTime must be two minutes later\");\r\n    require(msg.value%TEN_DECIMALS==0, \"invalid received BNB amount: precision loss in amount conversion\");\r\n    uint256 batchLength = amounts.length;\r\n    uint256 totalAmount = 0;\r\n    uint256 rewardForRelayer;\r\n    uint256[] memory convertedAmounts = new uint256[](batchLength);\r\n    for (uint i = 0; i < batchLength; i++) {\r\n      require(amounts[i]%TEN_DECIMALS==0, \"invalid transfer amount: precision loss in amount conversion\");\r\n      totalAmount = totalAmount.add(amounts[i]);\r\n      convertedAmounts[i] = amounts[i].div(TEN_DECIMALS);\r\n    }\r\n    require(msg.value>=totalAmount.add(relayFee.mul(batchLength)), \"received BNB amount should be no less than the sum of transfer BNB amount and relayFee\");\r\n    rewardForRelayer = msg.value.sub(totalAmount);\r\n\r\n    TransferOutSynPackage memory transOutSynPkg = TransferOutSynPackage({\r\n      bep2TokenSymbol: BEP2_TOKEN_SYMBOL_FOR_BNB,\r\n      contractAddr: address(0x00),\r\n      amounts: convertedAmounts,\r\n      recipients: recipientAddrs,\r\n      refundAddrs: refundAddrs,\r\n      expireTime: expireTime\r\n    });\r\n    ICrossChain(CROSS_CHAIN_CONTRACT_ADDR).sendSynPackage(TRANSFER_OUT_CHANNELID, encodeTransferOutSynPackage(transOutSynPkg), rewardForRelayer.div(TEN_DECIMALS));\r\n    emit transferOutSuccess(address(0x0), msg.sender, totalAmount, rewardForRelayer);\r\n    return true;\r\n  }\r\n\r\n  function updateParam(string calldata key, bytes calldata value) override external onlyGov{\r\n    require(value.length == 32, \"expected value length is 32\");\r\n    string memory localKey = key;\r\n    bytes memory localValue = value;\r\n    bytes32 bytes32Key;\r\n    assembly {\r\n      bytes32Key := mload(add(localKey, 32))\r\n    }\r\n    if (bytes32Key == bytes32(0x72656c6179466565000000000000000000000000000000000000000000000000)) { // relayFee\r\n      uint256 newRelayFee;\r\n      assembly {\r\n        newRelayFee := mload(add(localValue, 32))\r\n      }\r\n      require(newRelayFee <= 1e18 && newRelayFee%(TEN_DECIMALS)==0, \"the relayFee out of range\");\r\n      relayFee = newRelayFee;\r\n    } else {\r\n      require(false, \"unknown param\");\r\n    }\r\n    emit paramChange(key, value);\r\n  }\r\n\r\n  function getContractAddrByBEP2Symbol(bytes32 bep2Symbol) external view override returns(address) {\r\n    return bep2SymbolToContractAddr[bep2Symbol];\r\n  }\r\n\r\n  function getBep2SymbolByContractAddr(address contractAddr) external view override returns(bytes32) {\r\n    return contractAddrToBEP2Symbol[contractAddr];\r\n  }\r\n\r\n  function bindToken(bytes32 bep2Symbol, address contractAddr, uint256 decimals) external override onlyTokenManager {\r\n    bep2SymbolToContractAddr[bep2Symbol] = contractAddr;\r\n    contractAddrToBEP2Symbol[contractAddr] = bep2Symbol;\r\n    bep20ContractDecimals[contractAddr] = decimals;\r\n  }\r\n\r\n  function unbindToken(bytes32 bep2Symbol, address contractAddr) external override onlyTokenManager {\r\n    delete bep2SymbolToContractAddr[bep2Symbol];\r\n    delete contractAddrToBEP2Symbol[contractAddr];\r\n  }\r\n\r\n  function isMiniBEP2Token(bytes32 symbol) internal pure returns(bool) {\r\n     bytes memory symbolBytes = new bytes(32);\r\n     assembly {\r\n       mstore(add(symbolBytes, 32), symbol)\r\n     }\r\n     uint8 symbolLength = 0;\r\n     for (uint8 j = 0; j < 32; j++) {\r\n       if (symbolBytes[j] != 0) {\r\n         symbolLength++;\r\n       } else {\r\n         break;\r\n       }\r\n     }\r\n     if (symbolLength < MINIMUM_BEP20_SYMBOL_LEN + 5) {\r\n       return false;\r\n     }\r\n     if (symbolBytes[symbolLength-5] != 0x2d) { // '-'\r\n       return false;\r\n     }\r\n     if (symbolBytes[symbolLength-1] != 'M') { // ABC-XXXM\r\n       return false;\r\n     }\r\n     return true;\r\n  }\r\n\r\n  function convertToBep2Amount(uint256 amount, uint256 bep20TokenDecimals) internal pure returns (uint256) {\r\n    if (bep20TokenDecimals > BEP2_TOKEN_DECIMALS) {\r\n      return amount.div(10**(bep20TokenDecimals-BEP2_TOKEN_DECIMALS));\r\n    }\r\n    return amount.mul(10**(BEP2_TOKEN_DECIMALS-bep20TokenDecimals));\r\n  }\r\n\r\n  function convertFromBep2Amount(uint256 amount, uint256 bep20TokenDecimals) internal pure returns (uint256) {\r\n    if (bep20TokenDecimals > BEP2_TOKEN_DECIMALS) {\r\n      return amount.mul(10**(bep20TokenDecimals-BEP2_TOKEN_DECIMALS));\r\n    }\r\n    return amount.div(10**(BEP2_TOKEN_DECIMALS-bep20TokenDecimals));\r\n  }\r\n\r\n  function getBoundContract(string memory bep2Symbol) public view returns (address) {\r\n    bytes32 bep2TokenSymbol;\r\n    assembly {\r\n      bep2TokenSymbol := mload(add(bep2Symbol, 32))\r\n    }\r\n    return bep2SymbolToContractAddr[bep2TokenSymbol];\r\n  }\r\n\r\n  function getBoundBep2Symbol(address contractAddr) public view returns (string memory) {\r\n    bytes32 bep2SymbolBytes32 = contractAddrToBEP2Symbol[contractAddr];\r\n    bytes memory bep2SymbolBytes = new bytes(32);\r\n    assembly {\r\n      mstore(add(bep2SymbolBytes,32), bep2SymbolBytes32)\r\n    }\r\n    uint8 bep2SymbolLength = 0;\r\n    for (uint8 j = 0; j < 32; j++) {\r\n      if (bep2SymbolBytes[j] != 0) {\r\n        bep2SymbolLength++;\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n    bytes memory bep2Symbol = new bytes(bep2SymbolLength);\r\n    for (uint8 j = 0; j < bep2SymbolLength; j++) {\r\n        bep2Symbol[j] = bep2SymbolBytes[j];\r\n    }\r\n    return string(bep2Symbol);\r\n  }\r\n}",
      "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"value\",\"type\":\"bytes\"}],\"name\":\"paramChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"receiveDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"bep20Addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"refundAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"status\",\"type\":\"uint32\"}],\"name\":\"refundFailure\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"bep20Addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"refundAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"status\",\"type\":\"uint32\"}],\"name\":\"refundSuccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"rewardTo\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"bep20Addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"refundAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferInSuccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"bep20Addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"senderAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"relayFee\",\"type\":\"uint256\"}],\"name\":\"transferOutSuccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"channelId\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"msgBytes\",\"type\":\"bytes\"}],\"name\":\"unexpectedPackage\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BEP2_TOKEN_DECIMALS\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BEP2_TOKEN_SYMBOL_FOR_BNB\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BIND_CHANNELID\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CODE_OK\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CROSS_CHAIN_CONTRACT_ADDR\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ERROR_FAIL_DECODE\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GOV_CHANNELID\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GOV_HUB_ADDR\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INCENTIVIZE_ADDR\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INIT_MINIMUM_RELAY_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LIGHT_CLIENT_ADDR\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAXIMUM_BEP20_SYMBOL_LEN\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_BEP2_TOTAL_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_GAS_FOR_CALLING_BEP20\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_GAS_FOR_TRANSFER_BNB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MINIMUM_BEP20_SYMBOL_LEN\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RELAYERHUB_CONTRACT_ADDR\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REWARD_UPPER_LIMIT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SLASH_CHANNELID\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SLASH_CONTRACT_ADDR\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"STAKING_CHANNELID\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SYSTEM_REWARD_ADDR\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TEN_DECIMALS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOKEN_HUB_ADDR\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOKEN_MANAGER_ADDR\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TRANSFER_IN_CHANNELID\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TRANSFER_IN_FAILURE_INSUFFICIENT_BALANCE\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TRANSFER_IN_FAILURE_NON_PAYABLE_RECIPIENT\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TRANSFER_IN_FAILURE_TIMEOUT\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TRANSFER_IN_FAILURE_UNBOUND_TOKEN\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TRANSFER_IN_FAILURE_UNKNOWN\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TRANSFER_IN_SUCCESS\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TRANSFER_OUT_CHANNELID\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VALIDATOR_CONTRACT_ADDR\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"alreadyInit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"recipientAddrs\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"refundAddrs\",\"type\":\"address[]\"},{\"internalType\":\"uint64\",\"name\":\"expireTime\",\"type\":\"uint64\"}],\"name\":\"batchTransferOutBNB\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"bep20ContractDecimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"bep2Symbol\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"contractAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"}],\"name\":\"bindToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bscChainID\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"claimRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddr\",\"type\":\"address\"}],\"name\":\"getBep2SymbolByContractAddr\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddr\",\"type\":\"address\"}],\"name\":\"getBoundBep2Symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"bep2Symbol\",\"type\":\"string\"}],\"name\":\"getBoundContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"bep2Symbol\",\"type\":\"bytes32\"}],\"name\":\"getContractAddrByBEP2Symbol\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMiniRelayFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"channelId\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"msgBytes\",\"type\":\"bytes\"}],\"name\":\"handleAckPackage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"channelId\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"msgBytes\",\"type\":\"bytes\"}],\"name\":\"handleFailAckPackage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"channelId\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"msgBytes\",\"type\":\"bytes\"}],\"name\":\"handleSynPackage\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"relayFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"expireTime\",\"type\":\"uint64\"}],\"name\":\"transferOut\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"bep2Symbol\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"contractAddr\",\"type\":\"address\"}],\"name\":\"unbindToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"value\",\"type\":\"bytes\"}],\"name\":\"updateParam\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]",
      "ContractName": "TokenHub",
      "CompilerVersion": "v0.6.4+commit.1dca32f3",
      "OptimizationUsed": "1",
      "Runs": "200",
      "ConstructorArguments": "",
      "EVMVersion": "Default",
      "Library": "",
      "LicenseType": "None",
      "Proxy": "0",
      "Implementation": "",
      "SwarmSource": "ipfs://cf38311fc70c7842415f6e43694ca6a2795a904f0541302504db82e7675343ff"
    }
  ]
}